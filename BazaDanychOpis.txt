Baza Danych Szpitala Psychiatrycznego - Opis
--------------------------------------------
Wiktoria Maciasz, Piotr Rywczak


1.	Cel
Celem stworzenia tej bazy danych jest uporządkowane przechowywanie informacji o pacjentach psychiatrycznych. Dzięki zapisywaniu dat ich pobytów w szpitalu jak i poszczególnych badań możliwe będzie łatwe śledzenie zmian ich stanu zdrowotnego podczas kolejnych hospitalizacji oraz zaplanowanie nowych efektywnych strategii. 


2.	Główne założenia
W bazie danych przechowywane będą głównie szczegółowe informacje z wszystkich pobytów hospitalizowanych pacjentów w szpitalu oraz powiązane z nimi istotne dane. 
Zapisywane będą wyniki pacjentów z badań podstawowych (badanie moczu, krwi) umożliwiające wykluczenie organicznego pochodzenia chorób psychicznych, a także nadzorowanie wielu chorób towarzyszących np. u pacjentów geriatrycznych oraz historia wagi (pomocna w kontrolowaniu wpływu wielu leków na wahania wagi, oraz podczas monitorowania pacjentów anorektycznych/bulimicznych). Dla wybranych pacjentów zapisane zostaną punkty oceny z poszczególnych skali psychologicznych (Test na depresję Becca, skala manii Young’a, Test osobowości MMPI2, Test na narkomanię DUDIT, Skala uzależnienia od alkoholu AUDIT, Skala objawów pozytywnych i negatywnych w schizofrenii PANNS).
W danej bazie danych możliwy będzie także wgląd do szczegółów strategii leczenia pacjentów psychiatrycznych – diagnoza chorób psychicznych, pojawiające się objawy chorobowe, stosowane leki i ich dawki, lekarz/lekarze prowadzący konkretnego pacjenta. Zamieszczona zostanie również informacja na temat palenia papierosów – będą to praktyczne dane, ponieważ uzależnienie od tytoniu dotyczy dużego odsetka pacjentów, a może wpływać na efektywność niektórych leków. 
Baza danych ułatwi także komunikację z rodziną pacjenta przechowując numery kontaktowe, adresy mailowe do wyznaczonych osób, a także – w razie potrzeby do nawiązania ponownego kontaktu z samym pacjentem. 
Lekarze korzystający z przechowywanych danych będą mogli wyświetlić informacje na temat tego czy dany pacjent jest ubezpieczony. Dostaną również wgląd do leków refundowanych, dostępnych w szpitalu, ich kategorii oraz do interakcji lekowych, w momencie, kiedy wprowadzać będą politerapię różnymi lekami. Jest to bardzo użyteczne, ponieważ niektóre leki psychiatryczne stosowane w połączeniu często mogą zmieniać swoją efektywność. Do bazy danych zostaną dodane wszystkie obserwowalne polekowe objawy uboczne – również do wglądu lekarzy w celu dopracowania odpowiedniego leczenia. Dodatkowo spisany zostanie dostawca leków wraz z firmą farmaceutyczną je produkującą, umożliwi to wgląd między innymi w minimalne różnice w produkcji.
Jako dodatkowe dane w bazie danych zostanie zamieszczony stanowisko i kontakt do pracowników szpitala w celu ułatwienia komunikacji, a także wiadomość na temat zapełnienia i organizacji poszczególnych oddziałów.


3.	Możliwości
Oprócz praktycznego użycia danej bazy w prowadzeniu historii chorób pacjentów, nadzorowania ich zmieniającego się stanu zdrowia w czasie i wykorzystaniu tej wiedzy w przyszłym doborze odpowiednich strategii leczenia, utworzenie tej bazy danych da wiele dodatkowych możliwości. Największą z nich będzie składowanie olbrzymiej ilości informacji na temat pacjentów – ich płci, wieku, wagi, diagnoz, objawów chorobowych i powiązaniu tych danych z skutecznymi strategiami leczenia – takie działanie umożliwi w przyszłości zbudowanie odpowiednich algorytmów proponujących pewne leki z przeliczoną proponowaną ich dawką. Lekarz będzie mógł zestawić swoje zamierzenia z zasugerowanym przez algorytm leczeniem.  


4.	Ograniczenia przyjęte przy projektowaniu
Podczas tworzenia tej bazy danych ograniczyliśmy się do przechowywania danych dotyczących przede wszystkim pacjentów psychiatrycznych. Tak, aby docelowymi odbiorcami korzystającym z składowanych informacji byli lekarze/pielęgniarki.
Nie skupiliśmy się szczegółowo na organizacji oddziałów szpitalnych, historii rachunkowej szpitala czy na sprawach organizacyjnych. Są to obszary istotne w funkcjonowaniu samego szpitala, ale nie należące do naszego obszaru zainteresowań, dotyczącego przede wszystkim pomocy w doborze odpowiednich strategii leczenia spośród dostępnego szerokiego wachlarza leków na rynku.


5.	Diagram ER


6.	Schemat bazy danych (diagram relacji)


7.	Dodatkowe więzy integralności danych
Aby zachować integralność w bazie danych zastosowano klucze obce, dodatkowo ograniczenie check w tabelach, przykładowo: 
CREATE TABLE Pobyty (
	ID_pacjenta INT,
	DataPrzyjecia DATE,
	DataWypisu DATE,
	PRIMARY KEY (ID_Pacjenta, DataPrzyjecia),
	FOREIGN KEY(ID_Pacjenta) REFERENCES Pacjenci(ID),
	CHECK (DataWypisu>DataPrzyjecia)
);
Ograniczenie CHECK nie pozwala aby Data Wypisu była wcześniejsza niż Data Przyjęcia pacjenta. 

Zaprojektowano też funkcję sprawdzającą poprawność numeru pesel Pacjentów/Lekarzy oraz wyzwalacze sprawdzające modyfikowane dane w tabelach.


8.	Utworzone indeksy
Utworzenie indeksów w danej bazie danych umożliwi wzrost wydajności wyszukiwania poszczególnych inforamcji. Duże ilości danych przechowywala będzie przykładowo tabela Pacjenci, wyszukiwanie konkretnego nazwiska będzie ciągnęło za sobą więc duży koszt, ponieważ na kolumnie Nazwisko nie ma indeksu (tak więc tabela musiała zostać przejrzana w całości).
Kiedy na kolumnie Nazwisko zakładamy indeks typu nonclustered wydajność operacji select wzrośnie:
CREATE INDEX IX_Pacjenci_Nazwisko
ON Pacjenci (Nazwisko); 

W danej bazie danych również przydane okaże się wykorzystanie Filtered index, gdy będzie interesowało nas 'odfiltrowanie' z tabeli Pacjenci osób palących i niepalących, utworzenie indeksu znacznie obniży koszty zapytania. 
CREATE INDEX IX_Pacjenci_Nazwisko
ON Person (Nazwisko)
INCLUDE (Imie)
WHERE Palenie=1
Teraz wydajność danego polecenia rośnie:
SELECT Nazwisko,Imie
FROM Pacjenci
WHERE Palenie=1


9.	Opis stworzonych widoków/funkcji

  a. FUNKCJA WYLICZAJĄCA WIEK PACJENTA
Funkcja wyliczająca wiek pacjenta ma na celu zwracanie cały czas aktualnych danych - tak, aby nie trzeba było nieustannie modyfikować lat życia pacjenta przechowywanych w tabeli. Funkcja korzysta z daty urodzenia zapisanej w tabeli Pacjenci, jest poprawna co do dnia.
Jako że pożadanym wynikiem jest jedynie wiek, utworzona została funkcja skalarna:   
GO
Create function ObliczWiek(@idpacjenta INT) 
returns int 
as 
Begin 
    DECLARE @DataUro DATE
    SET @DataUro = (SELECT DataUrodzenia FROM Pacjenci WHERE ID =  @idpacjenta)
	IF MONTH(@DataUro) = MONTH(getdate()) and day(@DataUro)>day(getdate()) 
		return datediff(MONTH,@DataUro, getdate())/12 - 1
	return datediff(MONTH,@DataUro, getdate())/12
End
GO

  b. WIDOK PODAJĄCY INFORMACJE O DNIACH POBYTU W SZPITALU I LICZBIE HOSPITALIZACJI
Widok w łatwy sposób daje wgląd do liczby dni spędzonych w szpitalu podczas kolejnych hospitalizacji pacjentów. Informacja ta może być przydatna dla lekarzy, ponieważ daje głębszy wgląd w czas trwania leczenia i wskazówki na temat nawrotu choroby.
Dany widok łatwo jest otrzymać z wykorzystaniem fynkcji okna:
GO
CREATE VIEW Info_Pobyty AS
SELECT *,
	datediff(dd,DataPrzyjecia,DataWypisu) AS Dni,
    COUNT(*) OVER (PARTITION BY ID_pacjenta
		order by DataPrzyjecia
        RANGE BETWEEN unbounded preceding AND unbounded following) [Liczba pobytów ogółem] 
FROM Pobyty
GO

  c. WIDOK INFORMUJĄCY O WYPEŁNIENIU ODDZIALÓW SZPITALNYCH PRZEZ PACJENTÓW
W celu uniknięcia przechowywania nadmiaru niepotrzebnych danych w tabelach, stworzono widok ilustrujący obecne zapełnienie miejsc na oddziałach. Widok wyświetla aktualną liczbę osób na oddziale, liczbę wszystkich miejsc ogólem, a także liczbę miejsc pozostałych - wolnych, w ostatiej kolumnie wyświetlana jest pełna nazwa oddziału. Stworzenie widoku jest możliwe przez wgląd do historii leczenia pacjentów znajdującej się w tabeli "StrategieLeczenia" oraz tabeli "Oddziały", mieszczącej informacje na temat struktury szpitala. 
GO
CREATE VIEW DostepneMiejscaNaOddzialach AS
select count(*) as LiczbaOsobNaOddziale , t1.LiczbaWszystkichMiejsc, (t1.LiczbaWszystkichMiejsc-count(*)) AS PozostaleMiejsca ,t1.NazwaOddzialu from
(select ID_Pacjenta, o.IdOddzialu as ID_Oddzialu, MIN(o.NazwaOddzialy) AS NazwaOddzialu, MIN(o.LiczbaMiejsc) AS LiczbaWszystkichMiejsc
from StrategieLeczenia sl inner join oddzialy o
on o.IdOddzialu = sl.Id_Oddzialu
where DataZakonczenia is null
group by id_pacjenta, o.IdOddzialu) as t1
group by t1.ID_Oddzialu, t1.NazwaOddzialu, t1.LiczbaWszystkichMiejsc
GO

  d. WIDOK WYŚWIETLAJĄCY LEKARZY U ICH OBECNYCH PACJENTÓW
Widok zwraca przejrzystą tabelę z najbardziej istotnymi informacjami osobowymi (Imie, Nazwisko, Stanowisko, Stopien naukowy) na temat lekarzy, którzy obecnie prowadzą leczenie dla pacjentów. Dla pacjentów tabela zwraca między innymi unikatowy numer pesel. Odczytanie tabeli ułatwia kulumna 'Leczy' i zaznaczenie kierunku grotem strzalki. 
GO
CREATE VIEW vw_Pacjenci_Lekarzy AS
SELECT Pracownicy.Imie AS [Imie Lekarza], Pracownicy.Nazwisko [Nazwisko Lekarza], Pracownicy.Stanowisko, Pracownicy.StopienNaukowy, '=>' AS Leczy, Pacjenci.Imie [Imie Pacjenta], Pacjenci.Nazwisko [Nazwisko Pacjenta], Pacjenci.Pesel [PESEL Pacjenta]
FROM Pracownicy RIGHT JOIN StrategieLeczenia ON Pracownicy.ID = StrategieLeczenia.LekarzProwadzacy INNER JOIN Pacjenci ON StrategieLeczenia.ID_Pacjenta = Pacjenci.ID
GO

  e. FUNKCJA WYŚWIETLAJĄCA LEKARZA I JEGO OBECNYCH PACJENTÓW
Funkcja  o podobnym zadaniu jak wyżej.
Funkcja ta może pomóc w organizacji pracy w szpitalu, ponieważ wzrośnie świadomość rzeczywistego obłożenia pacjentami lekarzy. Do wygenerowania tych danych zastosowano funkcję tablicową, aby wywołać funkcję niezbędne jest wprowadzenie imienia i nazwiska interesującego nas lekarza. 
GO
CREATE FUNCTION f_Pacjenci_Lekarza ( @imie VARCHAR(256), @nazwisko VARCHAR(256) )
RETURNS table
AS
RETURN
(SELECT Pracownicy.Imie AS [Imie Lekarza], Pracownicy.Nazwisko [Nazwisko Lekarza], Pracownicy.Stanowisko, Pracownicy.StopienNaukowy, '=>' AS Leczy, Pacjenci.Imie [Imie Pacjenta], Pacjenci.Nazwisko [Nazwisko Pacjenta], Pacjenci.Pesel [PESEL Pacjenta]
FROM Pracownicy RIGHT JOIN StrategieLeczenia ON Pracownicy.ID = StrategieLeczenia.LekarzProwadzacy INNER JOIN Pacjenci ON StrategieLeczenia.ID_Pacjenta = Pacjenci.ID
WHERE Pracownicy.ID IN (
SELECT Pracownicy.ID FROM Pracownicy
WHERE Pracownicy.Imie = @imie AND Pracownicy.Nazwisko = @nazwisko))
GO

  f. Widok zwracający częstość występowania danych jednostek chorobowych w szpitalu
Użyteczny widok wyświetlający podsumowanie danych z całego szpitala - select zwraca liczbę danych jednostek chorobowych w sumie. Pozwala to na lepsze rozporządzanie zamówieniami na leki i zatrudnieniem odpowiednich specjalistów.
Połączono tabele: 'Pacjenci', 'WszystkieChorobyPacjentów' (ponieważ jeden pacjent może mieć więcej niż jedną diagnozę) i 'Choroby', następnie wynik pogrupowano odpowiednio i wyświetlono interesujące dane.
GO
CREATE VIEW CzestoscWystepowaniaJednostekChoorbowych AS
SELECT COUNT(*) AS [Liczba Pacjentów], NazwaChoroby [Nazwa Choroby] FROM Pacjenci P
INNER JOIN 
WszystkieChorobyPacjentow WCP ON P.ID = WCP.ID_Pacjenta
INNER JOIN
Choroby C ON WCP.ID_Choroby=C.IDChoroby
GROUP BY NazwaChoroby
GO

  g. Widok ilustrujący najpopularniejsze leki używane przez lekarzy w terapii pacjentów w danym szpitalu
Do stworzenia tego wyniku połączono tabele 'StrategieLeczenia' przechowującą historię hospitalizacji pacjentów i poszczególnych ich lekarzy prowadzących, tabelę 'Leki' oraz 'Pracownicy', z której wydzielono tylko lekarzy. Operacje te miały na celu uzyskanie danych o popularności danych leków stosowanych w terapiach i wybieranych przez konkretnych lekarzy. Ma to na celu zwiększyć możliwości stosowania najbardziej odpowiednich medykamentów.    
GO
CREATE VIEW UzycieLekow AS
SELECT P.ID, P.Imie, P.Nazwisko, L.NazwaLeku, COUNT(NazwaLeku) Ilość FROM Pracownicy P
INNER JOIN StrategieLeczenia SL
ON P.ID=SL.LekarzProwadzacy
INNER JOIN Leki L ON L.ID= SL.ID_LEKU 
WHERE P.Stanowisko = 'Lekarz'
GROUP BY P.Nazwisko, L.NazwaLeku, P.ID, P.Imie
GO

  h. FUNKCJA pokazująca pacjenta i jego obecnych lekarzy
Funkcja ma na celu szybkie znalezienie lekarza prowadzącego wybranego pacjenta. W odróżnieniu do funkcji e. f_Pacjeci_Lekarza, dana funkcja do wywołania  potrzebuje imię i nazwisko inetersującego nas pacjenta. Jest to funkcja tablicowa, w środku zawiera pomocniczą kolumnę z grotami strzałek ułatwiającą zrozumienie relacji między wyświetlanymi osobami.
GO
CREATE FUNCTION f_Lekarze_Pacjenta ( @imie VARCHAR(256), @nazwisko VARCHAR(256) )
RETURNS table
AS
RETURN
(SELECT Pracownicy.Imie AS [Imie Lekarza], Pracownicy.Nazwisko [Nazwisko Lekarza], Pracownicy.Stanowisko, Pracownicy.StopienNaukowy, '=>' AS Leczy, Pacjenci.Imie [Imie Pacjenta], Pacjenci.Nazwisko [Nazwisko Pacjenta], Pacjenci.Pesel [PESEL Pacjenta]
FROM Pracownicy RIGHT JOIN StrategieLeczenia ON Pracownicy.ID = StrategieLeczenia.LekarzProwadzacy INNER JOIN Pacjenci ON StrategieLeczenia.ID_Pacjenta = Pacjenci.ID
WHERE Pacjenci.ID IN (
SELECT Pacjenci.ID FROM Pacjenci
WHERE Pacjenci.Imie = @imie AND Pacjenci.Nazwisko = @nazwisko))
GO

  i. FUNKCJA SPRAWDZAJĄCA POPRAWNOŚĆ NUMERU PESEL PACJENTÓW W SZPITALU 
  Funkcja ma na celu sprawdzać poprawność podanych numerów pesel pacjentów z wykorzytaniem sumy kontrolnej.
GO
CREATE FUNCTION CheckPESEL ( @PESEL VARCHAR(256) )
RETURNS BIT
AS
	BEGIN
	DECLARE @sum INT
	DECLARE @controlSum INT
	DECLARE @result BIT
	SET @controlSum = CAST( SUBSTRING(@PESEL, 11, 1) AS INT)
	SET @sum = CAST( SUBSTRING(@PESEL, 1, 1) AS INT) -- 1
	SET @sum = ( @sum + CAST( SUBSTRING(@PESEL, 2, 1) AS INT) * 3 ) % 10 -- 3
	SET @sum = ( @sum + CAST( SUBSTRING(@PESEL, 3, 1) AS INT) * 7 ) % 10 -- 7
	SET @sum = ( @sum + CAST( SUBSTRING(@PESEL, 4, 1) AS INT) * 9 ) % 10 -- 9
	SET @sum = ( @sum + CAST( SUBSTRING(@PESEL, 5, 1) AS INT) * 1 ) % 10 -- 1
	SET @sum = ( @sum + CAST( SUBSTRING(@PESEL, 6, 1) AS INT) * 3 ) % 10 -- 3
	SET @sum = ( @sum + CAST( SUBSTRING(@PESEL, 7, 1) AS INT) * 7 ) % 10 -- 7
	SET @sum = ( @sum + CAST( SUBSTRING(@PESEL, 8, 1) AS INT) * 9 ) % 10 -- 9
	SET @sum = ( @sum + CAST( SUBSTRING(@PESEL, 9, 1) AS INT) * 1 ) % 10 -- 1
	SET @sum = ( @sum + CAST( SUBSTRING(@PESEL, 10, 1) AS INT) * 3 ) % 10 -- 3
	SET @sum = ( 10 - (@sum % 10) ) % 10
	IF @sum = @controlSum
		SET @result=1
	ELSE
		SET @result=0
	RETURN @result
	END
GO

	j. WIDOK ILUSTRUJĄCY PRACOWNIKÓW 'MEDYCZNICH' SZPITALA
GO
CREATE VIEW vw_Pracownicy_Medyczni AS
SELECT * FROM Pracownicy
WHERE Stanowisko IN ('Lekarz', 'Pielęgniarz', 'Diagnostyk Laboratoryjny', 'Asystent Medyczny')
GO

	k.  WIDOK ILUSTRUJĄCY PRACOWNIKÓW 'BIUROWYCH' SZPITALA

Go
CREATE VIEW vw_Pracownicy_Biurowi AS
SELECT * FROM Pracownicy
WHERE Stanowisko IN ('Sekretarz', 'Dyrektor')
GO

	l. WIDOK ILUSTRUJĄCY PRACOWNIKÓW - DIETETYKÓW
Go
CREATE VIEW vw_Dietetycy AS
SELECT * FROM Pracownicy
WHERE Stanowisko IN ('Dietetyk')
GO


10.	Opis procedur składowanych

	a. PROCEDURA WYLICZAJĄCA BMI DLA WSKAZANEGO PACJENTA
Procedura wylicza BMI dla danego pacjeta po wprowadzeniu jego ID oraz daty pomiaru, jest to możliwe ponieważ w tabeli Pacjenci jest zawarta informacja o wzroście w cm, a w szpitalu prowadzone pomiary wagi zapisywane w tabeli 'HistoriaWagi'. Są to przydatne informacje pod kątem sprawdzania efektów ubocznych niektórych leków psychiatrycznych wywołujących zwiększone tycie. Z drugiej strony historia zapisywana w tabeli i wyliczane BMI pozwoli na lepszą kontrolę stanu zdrowia osób z bulimią/anoreksją w szpitalu. 
GO
create proc bmi (@idpacjenta int, @data date) as 
    declare @waga FLOAT
    set @waga = (select waga from HistoriaWagi where id_pacjenta = @idpacjenta and datapomiaru = @data)
    declare @wzrost FLOAT 
    set @wzrost = (select wzrost from Pacjenci where id = @idpacjenta)
    declare @bmi FLOAT
    set @bmi= (@waga)/POWER((@wzrost/100),2)
    return @bmi 
GO


	b. Procedura sprawdzająca prawidłowość wyniku z badania moczu pacjenta. 
Procedura sprawdza czy wyniki badania moczu pacjenta mieszczą się w podanych granicach normy, umożliwiają to konstrukcje warunkowe, które zwracają odpowiendi komunikat. Jest to w celu ułatwienia uzyskania szybciej diagnozy, wynik zwracany może też być dostępny dla pacjenta, który otrzyma ocenę swojego badania w prostej formie.  
GO
CREATE PROC WynikiMoczu (@id_pacjenta INT, @data DATE) AS
	DECLARE @Barwa VARCHAR(256) 
	SET @Barwa = (SELECT Barwa FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @Barwa = 'słomkowy'
		PRINT 'Barwa moczu: Prawidłowa'
	ELSE
		PRINT 'Barwa moczu: Nieprawidłowa '
	DECLARE @Klarownosc BIT
	SET @Klarownosc = (SELECT Klarownosc FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @Klarownosc = 1
		PRINT 'Klarowność moczu: Mocz klarowny'
	ELSE
		PRINT 'Klarowność moczu: Mocz nieklarowny'
	DECLARE @OdczynPh FLOAT
	SET @OdczynPh = (SELECT OdczynPh FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @OdczynPh >4.5 AND @OdczynPh <8 
		PRINT 'Odczyn pH moczu: Prawidłowy'
	ELSE
		PRINT 'Odczyn pH moczu: Nierawidłowy'
	DECLARE @CiezarMoczu FLOAT
	SET @CiezarMoczu = (SELECT CiezarMoczu FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @CiezarMoczu >1.005 AND @CiezarMoczu <1.035
		PRINT 'Ciężar moczu: Prawidłowy'
	ELSE
		PRINT 'Ciężar moczu: Nierawidłowy'	
	DECLARE @Leukocyty BIT
	SET @Leukocyty = (SELECT Leukocyty FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @Leukocyty = 0
		PRINT 'Brak obecności leukocytów w moczu - wynik prawidłowy'
	ELSE
		PRINT 'Obecność leukocytów w moczu - wynik nieprawidłowy'
	DECLARE @Hemoglobina BIT
	SET @Hemoglobina = (SELECT Hemoglobina FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @Hemoglobina = 0
		PRINT 'Brak obecności hemoglobiny w moczu - wynik prawidłowy'
	ELSE
		PRINT 'Obecność hemoglobiny w moczu - wynik nieprawidłowy'
	DECLARE @Bilirubina BIT
	SET @Bilirubina = (SELECT Bilirubina FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @Bilirubina = 0
		PRINT 'Brak obecności bilirubiny w moczu - wynik prawidłowy'
	ELSE
		PRINT 'Obecność bilirubiny w moczu - wynik nieprawidłowy'
	DECLARE @Urobilinogen BIT
	SET @Urobilinogen = (SELECT Urobilinogen FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @Urobilinogen = 0
		PRINT 'Brak obecności urobilinogenu w moczu - wynik prawidłowy'
	ELSE
		PRINT 'Obecność urobilinogenu w moczu - wynik nieprawidłowy'
	DECLARE @Bialko BIT
	SET @Bialko = (SELECT Bialko FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @Bialko = 0
		PRINT 'Brak obecności białka w moczu - wynik prawidłowy'
	ELSE
		PRINT 'Obecność białka w moczu - wynik nieprawidłowy'
	DECLARE @Glukoza BIT
	SET @Glukoza = (SELECT Glukoza FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @Glukoza = 0
		PRINT 'Brak obecności glukozy w moczu - wynik prawidłowy'
	ELSE
		PRINT 'Obecność glukozy w moczu - wynik nieprawidłowy'
	DECLARE @Ketony BIT
	SET @Ketony = (SELECT Ketony FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @Ketony = 0
		PRINT 'Brak obecności ketonów w moczu - wynik prawidłowy'
	ELSE
		PRINT 'Obecność ketonów w moczu - wynik nieprawidłowy'
	DECLARE @Azotyny BIT
	SET @Azotyny = (SELECT Azotyny FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @Azotyny = 0
		PRINT 'Brak obecności azotynów w moczu - wynik prawidłowy'
	ELSE
		PRINT 'Obecność azotynów w moczu - wynik nieprawidłowy' 
GO

	c. Procedura zwracająca prawidłowość wyników krwi pacjentów 
Procedura ocenia podstawowe wyniki morfologii krwi, bierze poprawkę na wyznaczone normy osobno dla mężczyzn i kobiet. Tak samo jak w przypadku badania moczu, procedura ma usprawniać postawienie diagnozy oraz może być bardziej przystępną informacją dla pacjenta.
GO
CREATE PROC WynikiKrwi (@id_pacjenta INT, @dataczas DATETIME) AS
	DECLARE @Erytrocyty FLOAT
	DECLARE @plec VARCHAR(256)
	SET @Erytrocyty = (SELECT Erytrocyty FROM BadanieKrwi WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @dataczas)
	SET @plec = (SELECT plec FROM Pacjenci WHERE ID = @id_pacjenta)
	IF (@Erytrocyty BETWEEN 3.5 AND 5.2 AND @plec='K') OR (@Erytrocyty BETWEEN 4.5 AND 5.4 AND @plec='M')
	PRINT('Liczba erytrocytów liczona w mln/mm3 - prawidłowa')
	ELSE
	PRINT('Liczba erytrocytów liczona w mln/mm3 - nieprawidłowa')	
	DECLARE @Leukocyty FLOAT
	SET @Leukocyty = (SELECT Leukocyty FROM BadanieKrwi WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @dataczas)
	IF @Leukocyty BETWEEN 4 AND 10
	PRINT('Liczba leukocytów liczona w tys./μl - prawidłowa')
	ELSE
	PRINT('Liczba leukocytów liczona w tys./μl - nieprawidłowa')
	DECLARE @Hemoglobina FLOAT
	SET @Hemoglobina = (SELECT Hemoglobina FROM BadanieKrwi WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @dataczas)
	IF (@Hemoglobina BETWEEN 12 AND 16 AND @plec='K') OR (@Hemoglobina BETWEEN 13 AND 18 AND @plec='M')
	PRINT('Ilość hemoglobiny liczona w g/dl - prawidłowa')
	ELSE
	PRINT('Ilość hemoglobiny liczona w g/dl - nieprawidłowa')	
	DECLARE @Hematokryt FLOAT
	SET @Hematokryt = (SELECT Hematokryt FROM BadanieKrwi WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @dataczas)
	IF (@Hematokryt BETWEEN 37 AND 47 AND @plec='K') OR (@Hematokryt BETWEEN 40 AND 50 AND @plec='M')
	PRINT('Hematokryt (%) prawidłowy')
	ELSE
	PRINT('Hematokryt (%) nieprawidłowy')	
	DECLARE @PlytkiKrwi FLOAT
	SET @PlytkiKrwi = (SELECT PlytkiKrwi FROM BadanieKrwi WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @dataczas)
	IF @PlytkiKrwi BETWEEN 150 AND 400
	PRINT('Liczba płytek krwi liczona w tys./μl - prawidłowa')
	ELSE
	PRINT('Liczba płytek krwi liczona w tys./μl - nieprawidłowa')
	DECLARE @Glukoza FLOAT
	SET @Glukoza = (SELECT Glukoza FROM BadanieKrwi WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @dataczas)
	IF @Glukoza BETWEEN 80 AND 140
	PRINT('Poziom glukozy (mg/dl) - prawidłowy')
	ELSE
	PRINT('Poziom glukozy (mg/dl) - nieprawidłowy')
GO

	d. Procedura oceniająca wyniki pacjenta w skali depresji Becca 
Procedura po wprowadzeniu ID pacjenta oraz odpowiedniej daty badania zwraca interpretację wyników z testu Becca, wykorzystywanego podczas badania depresji. Procedura ma na celu ułatwić komunikację między psychologami a lekarzami, a także umożliwić odczytanie wyniku samemu pacjentowi w przystępnej formie.

GO
CREATE PROC TestBecca(@id_pacjenta INT, @data DATE) AS
    DECLARE @wynik INT
    SET @wynik = (SELECT TestBECCA FROM WynikiDanychPsychologicznych WHERE ID_Pacjenta = @id_pacjenta AND Data = @data)
    IF @wynik BETWEEN 0 AND 11
    PRINT 'brak depresji' 
    ELSE 
        IF @wynik BETWEEN 12 AND 19
        PRINT 'lekka depresja' 
        ELSE
            IF @wynik BETWEEN 20 AND 25
            PRINT 'umiarkowana depresja' 
            ELSE
                IF @wynik > 26 
                PRINT 'ciężka depresja' 
GO


	e. Procedura oceniająca epizod maniakalny w chorobie afektywnej dwubiegunowej za pomocą skali Younga
Procedura działająca analogicznie do procedury opisanej wyżej (d. SkalaBECCA), w tym przypadku oceniane jest nasilenie epizodów manii u pacjentów z chorobą afektywną dwubiegunową. Funkcja ma ułatwić komunikację psycholog-lekarz i lekarz-pacjnt. Do budowy procedury wykorzystano konstrukcje warunkowe.
GO
CREATE PROC SkalaYOUNGA(@id_pacjenta INT, @data DATE) AS
    DECLARE @wynik INT
    SET @wynik = (SELECT SkalaYounga FROM WynikiDanychPsychologicznych WHERE ID_Pacjenta = @id_pacjenta AND Data = @data)
    IF @wynik BETWEEN 0 AND 12
    PRINT 'remisja manii' 
    ELSE 
        IF @wynik BETWEEN 13 AND 19
        PRINT 'minimalne symptomy manii' 
        ELSE
            IF @wynik BETWEEN 20 AND 25
            PRINT 'hipomania' 
            ELSE
                IF @wynik BETWEEN 26 AND 37
                PRINT 'umiarkowana mania'
                ELSE
                    IF @wynik>37
                    PRINT 'ciężka mania'
GO


	f. Procedura oceniająca uzależnienie pacjenta od alkoholu z wykorzystaniem skali AUDIT;
Procedura do oceny uzależnienie pacjenta od alkoholu w skali AUDIT - działa jak powyższe (d. skalaBECCA,e. skalaYOUNGA). Ułatwia interpretację otrzymanych zwrotnie wyników punktowych.
GO
CREATE PROC SkalaAudit (@id_pacjenta INT, @data DATE) AS
    DECLARE @wynik INT
    SET @wynik = (SELECT SkalaAUDIT FROM WynikiDanychPsychologicznych WHERE ID_Pacjenta = @id_pacjenta AND Data = @data)
    IF @wynik >=8
    PRINT 'wskazane pogłębione badanie diagnostyczne u terapeuty uzależnień' 
    ELSE 
    PRINT 'wynik w normie' 
    RETURN @wynik
GO

	h. Procedura dodająca strategię leczenia dla danego pacjenta
Procedura dodająca strategię leczenia dla danego pacjenta (imie, nazwisko, pesel) przypisując mu lekarza
GO
CREATE PROC DodajLeczenie(@imie_pacj VARCHAR(256), @nazwisko_pacj VARCHAR(256), @pesel_pacj VARCHAR(11), @imie_lek VARCHAR(256), @nazw_lek VARCHAR(256), @pesel_lek VARCHAR(11))
AS
	BEGIN
		DECLARE @id_pacj INT
		SELECT @id_pacj = Pacjenci.ID FROM Pacjenci WHERE Pacjenci.PESEL = @pesel_pacj
		DECLARE @id_lek INT
		SELECT @id_lek = Pracownicy.ID FROM Pracownicy WHERE Pracownicy.PESEL = @pesel_lek
		INSERT INTO StrategieLeczenia VALUES
		( @id_pacj, NULL, NULL, NULL, @id_lek, NULL, GETDATE(), NULL )
		SELECT * FROM StrategieLeczenia
	END
GO

	i) Procedura wpisująca detale leczenia pacjenta.
Procedura wpisująca szczegóły prowadzonego leczenia pacjenta. Umożliwi to szybki wgląd dowolnego lekarza w proces leczenia. Jest to przydatne narzędzie, ponieważ niesie najbardziej istotne informacje podczas omawiania przypadku danego pacjenta na zebraniach grupowych. 
GO
CREATE PROC UzupelnijLeczenie ( @id_leczenia INT, @choroba VARCHAR(256), @lek VARCHAR(256), @dawka VARCHAR(256), @oddzial VARCHAR(256) )
AS
	BEGIN
		DECLARE @id_choroby INT
		SELECT @id_choroby = Choroby.ID FROM Choroby WHERE Choroby.NazwaChoroby = @choroba
		DECLARE @id_leku INT
		SELECT @id_leku = Leki.ID FROm Leki WHERE Leki.NazwaLeku = @lek
		DECLARE @id_oddzialu INT
		SELECT @id_oddzialu = Oddzialy.IdOddzialu FROm Oddzialy WHERE Oddzialy.NazwaOddzialy = @oddzial
		UPDATE StrategieLeczenia
		SET ID_Choroby = @id_choroby, ID_Leku = @id_leku, DawkaLeku = @dawka, ID_Oddzialu = @id_oddzialu
		WHERE ID = @id_leczenia
		SELECT * FROM StrategieLeczenia
	END
GO

	j) Procedura wpisująca datę końcową leczenia
Procedura uzupełniająca historię choroby - po zakończeniu leczenia (stosowaniu odpowiedniego leku w określonej dawce) zapisuje informacje o dacie zakończenia w bazie danych.
CREATE PROC ZakonczLeczenie (@id_leczenia INT)
AS
	BEGIN
	DECLARE @TEXT VARCHAR(256)
	IF (SELECT DataZakonczenia FROM StrategieLeczenia WHERE StrategieLeczenia.ID = @id_leczenia) IS NULL BEGIN
		UPDATE StrategieLeczenia
		SET DataZakonczenia = GETDATE()
		WHERE ID = @id_leczenia
		SET @TEXT = 'Leczenie zakonczone'
		END
	ELSE
		SET @TEXT = 'Leczenie już było zakonczone'

	PRINT ( @TEXT )
	SELECT * FROM StrategieLeczenia
	END
GO


11.	Opis wyzwalaczy

	a. Prosty wyzwalacz przekazujący informacje o update'owaniu pobytów pacjentów w szpitalu 
GO
CREATE TRIGGER TR_UPDATE_Pobyty ON Pobyty
AFTER UPDATE
AS
PRINT 'Zmodyfikowanio zawartość danych na temat pobytów pacjentów w szpitalu.'
SELECT * FROM deleted
SELECT * FROM inserted
GO

	b. Prosty wyzwalacz przekazujący informacje o dodaniu nowych pracowników szpitala
GO
CREATE TRIGGER TR_AFTER_INSERT_Pracownicy ON Pracownicy
AFTER INSERT
AS
PRINT 'Dodano nowego pracownika szpitala.'
SELECT * FROM inserted
GO

	c. Prosty wyzwalacz przekazujący informacje o dodaniu nowych diagnoz dla pacjentów
GO
CREATE TRIGGER TR_INSERT_WszystkieChorobyPacjentow ON WszystkieChorobyPacjentow
AFTER INSERT
AS
PRINT 'Dodano nową diagnozę.'
SELECT * FROM inserted
GO

	d. Prosty wyzwalacz przekazujący informacje o dodaniu nowej strategii leczenia

GO
CREATE TRIGGER TR_INSERT_StrategieLeczenia ON StrategieLeczenia
AFTER INSERT
AS
PRINT 'Dodano nową strategię leczenia pacjenta.'
SELECT * FROM inserted
GO

	e. WYZWALACZ INSTEAD OF INSERT NA TABELI PACJENCI SPRAWDZAJĄCY DODAWANE DANE DO TABELI PACJENCI- 
Wyzwalacz (instead of insert) stworzony dla tabeli 'Pacjenci' ma za zadanie sprawdzać poprawność i zgodność dodawanego pesela oraz daty
GO
CREATE TRIGGER TR_INSERT_Pacjenci ON Pacjenci
INSTEAD OF INSERT
AS
	DECLARE @TEXT NVARCHAR(256)
	DECLARE @unique BIT
	DECLARE @pesel VARCHAR(256)
	SET @unique = 1
	DECLARE ITERATOR CURSOR FOR
	SELECT Imie, Nazwisko, Plec, DataUrodzenia, Pesel, Palenie, Wzrost FROM inserted
	OPEN Iterator
	DECLARE @imie VARCHAR(256)
	DECLARE @nazwisko VARCHAR(256)
	DECLARE @plec VARCHAR(256)
	DECLARE @dataurodzenia DATE
	DECLARE @palenie BIT
	DECLARE @wzrost INT
	DECLARE @peselDateGood BIT
	DECLARE @peselGood BIT
	FETCH Iterator INTO @imie, @nazwisko, @plec, @dataurodzenia, @pesel, @palenie, @wzrost
	WHILE (@@FETCH_STATUS = 0 ) BEGIN
		SET @peselDateGood = 1
		SET @peselGood = 1
		SET @unique = 1
		-- sprawdzenie czy pesel jest unique
		IF @pesel IN ( SELECT Pesel FROM Pacjenci ) BEGIN
			SET @TEXT = FORMATMESSAGE ('Nie dodano pacjenta Pesel: %s. Pesel jest już w bazie danych',@pesel)
			SET @unique = 0
		END
		-- sprawdzenie daty i daty w peselu
		IF ( @pesel IS NOT NULL ) AND ( @dataurodzenia IS NOT NULL ) BEGIN
			DECLARE @peselday VARCHAR(2)
			DECLARE @peselmonth VARCHAR(2)
			DECLARE @peselyear VARCHAR(256)
			DECLARE @peselmonthright CHAR(1)
			DECLARE @peselmonthleft CHAR(1)
			DECLARE @peselcentury CHAR(2)
			SET @peselday = SUBSTRING(@pesel, 5, 2)
			SET @peselmonthleft = SUBSTRING(@pesel, 3, 1)
			IF @peselmonthleft IN (0, 1)
				SET @peselcentury = '19'
			IF @peselmonthleft IN (2, 3)
				SET @peselcentury = '20'
			IF @peselmonthleft IN (4, 5)
				SET @peselcentury = '21'
			IF @peselmonthleft = 2
				SET @peselmonthleft = '0'
			IF @peselmonthleft = 3
				SET @peselmonthleft = '1'
			IF @peselmonthleft = 4
				SET @peselmonthleft = '0'
			IF @peselmonthleft = 5
				SET @peselmonthleft = '1'
			SET @peselmonthright = SUBSTRING(@pesel, 4, 1)
			SET @peselmonth = @peselmonthleft + @peselmonthright
			SET @peselyear = SUBSTRING(@pesel, 1, 2)
			DECLARE @peseldate VARCHAR(256)
			SET @peseldate = @peselcentury + @peselyear + '-' + @peselmonth + '-' + @peselday
			DECLARE @datedate VARCHAR(256)
			SET @datedate = SUBSTRING( CAST(@dataurodzenia as char), 1, 11)
			--PRINT @datedate
			--PRINT @peseldate
			IF @datedate = @peseldate
				SET @peselDateGood = 1
			ELSE
				SET @peselDateGood = 0
		END
		IF (@pesel IS NOT NULL ) BEGIN
			-- sprawwdzenie pesela
			--PRINT dbo.CheckPesel(@pesel)
			IF dbo.CheckPesel(@pesel) = 0
				SET @peselGood = 0
		END
		IF (@peselDateGood = 1 AND @peselGood = 1 AND @unique = 1) BEGIN
		INSERT INTO Pacjenci VALUES (@imie, @nazwisko, @plec, @dataurodzenia, @pesel, @palenie, @wzrost)
		SET @TEXT = FORMATMESSAGE (
		'Dodano pacjenta %s %s Pesel: %s Data Urodzenia: %s',
		@imie, @nazwisko, @pesel, SUBSTRING(CAST(@dataurodzenia as char), 1, 10)
		)
		END
		IF (@peselGood = 0) BEGIN
		SET @TEXT = FORMATMESSAGE (
		'Nie dodano pacjenta %s %s. Błędny Pesel: %s',
		@imie, @nazwisko, @pesel)
		END
		IF (@peselDateGood = 0) BEGIN
		SET @TEXT = FORMATMESSAGE (
		'Nie dodano pacjenta %s %s Pesel: %s Data Urodzenia: %s, błędny PESEL lub data urodzenia',
		@imie, @nazwisko, @pesel, SUBSTRING(CAST(@dataurodzenia as char), 1, 10)
		)
		END	
	PRINT @TEXT
	FETCH Iterator INTO @imie, @nazwisko, @plec, @dataurodzenia, @pesel, @palenie, @wzrost
END
CLOSE Iterator
DEALLOCATE Iterator
GO


	f. WYZWALACZ INSTEAD OF UPDATE NA TABELI PACJENCI SPRAWDZAJĄCY MODYFIKOWANE DANE DO TABELI PACJENCI- POPRAWNOŚĆ/ZGODNOŚĆ PESELA I DATY
Wyzwalacz (instead of update) stworzony dla tabeli 'Pacjenci' ma za zadanie sprawdzać poprawność i zgodność pesela oraz daty podczas ich modyfikacji
GO
CREATE TRIGGER TR_UPDATE_Pacjenci ON Pacjenci
INSTEAD OF UPDATE
AS
	DECLARE ITERATOR CURSOR FOR
	SELECT ID, Imie, Nazwisko, Plec, DataUrodzenia, Pesel, Palenie, Wzrost FROM inserted
	OPEN Iterator
	DECLARE @id INT
	DECLARE @imie VARCHAR(256)
	DECLARE @nazwisko VARCHAR(256)
	DECLARE @plec VARCHAR(256)
	DECLARE @dataurodzenia DATE
	DECLARE @pesel VARCHAR(256)
	DECLARE @palenie BIT
	DECLARE @wzrost INT
	DECLARE @peselDateGood BIT
	DECLARE @TEXT NVARCHAR(256)
	--SET IDENTITY_INSERT Pacjenci ON
	FETCH Iterator INTO @id, @imie, @nazwisko, @plec, @dataurodzenia, @pesel, @palenie, @wzrost
	WHILE (@@FETCH_STATUS = 0 ) BEGIN
		-- sprawdzenie daty i daty w peselu
		DECLARE @peselday VARCHAR(2)
		DECLARE @peselmonth VARCHAR(2)
		DECLARE @peselyear VARCHAR(256)
		DECLARE @peselmonthright CHAR(1)
		DECLARE @peselmonthleft CHAR(1)
		DECLARE @peselcentury CHAR(2)
		SET @peselday = SUBSTRING(@pesel, 5, 2)
		SET @peselmonthleft = SUBSTRING(@pesel, 3, 1)
		IF @peselmonthleft IN (0, 1)
			SET @peselcentury = '19'
		IF @peselmonthleft IN (2, 3)
			SET @peselcentury = '20'
		IF @peselmonthleft IN (4, 5)
			SET @peselcentury = '21'
		IF @peselmonthleft = 2
			SET @peselmonthleft = '0'
		IF @peselmonthleft = 3
			SET @peselmonthleft = '1'
		IF @peselmonthleft = 4
			SET @peselmonthleft = '0'
		IF @peselmonthleft = 5
			SET @peselmonthleft = '1'
		SET @peselmonthright = SUBSTRING(@pesel, 4, 1)
		SET @peselmonth = @peselmonthleft + @peselmonthright
		SET @peselyear = SUBSTRING(@pesel, 1, 2)
		DECLARE @peseldate VARCHAR(256)
		SET @peseldate = @peselcentury + @peselyear + '-' + @peselmonth + '-' + @peselday
		DECLARE @datedate VARCHAR(256)
		SET @datedate = SUBSTRING( CAST(@dataurodzenia as char), 1, 11)
		--PRINT @datedate
		--PRINT @peseldate
		IF @datedate = @peseldate
			SET @peselDateGood = 1
		ELSE
			SET @peselDateGood = 0
		-- sprawwdzenie pesela
		--PRINT dbo.CheckPesel(@pesel)
		DECLARE @peselGood BIT
		IF dbo.CheckPesel(@pesel) = 1
			SET @peselGood = 1
		ELSE
			SET @peselGood = 0
		IF (@peselDateGood = 1 AND @peselGood = 1) BEGIN
		UPDATE Pacjenci
		SET Imie = @imie, Nazwisko = @nazwisko, Plec = @plec, DataUrodzenia = @dataurodzenia, Pesel = @pesel, Palenie = @palenie, Wzrost = @wzrost
		WHERE Pacjenci.ID = @id
		SET @TEXT = FORMATMESSAGE (
		'Zmodyfikowano pacjenta %s %s Pesel: %s Data Urodzenia: %s',
		@imie, @nazwisko, @pesel, SUBSTRING(CAST(@dataurodzenia as char), 1, 10)
		)
		END
		IF (@peselGood = 0) BEGIN
		SET @TEXT = FORMATMESSAGE (
		'Nie zmodyfikowano pacjenta %s %s. Błędny Pesel: %s',
		@imie, @nazwisko, @pesel)
		END
		IF (@peselDateGood = 0) BEGIN
		SET @TEXT = FORMATMESSAGE (
		'Nie zmodyfikowano pacjenta %s %s Pesel: %s Data Urodzenia: %s, błędny PESEL lub data urodzenia',
		@imie, @nazwisko, @pesel, SUBSTRING(CAST(@dataurodzenia as char), 1, 10)
		)
		END
	PRINT @TEXT
	FETCH Iterator INTO @id, @imie, @nazwisko, @plec, @dataurodzenia, @pesel, @palenie, @wzrost
END
CLOSE Iterator
DEALLOCATE Iterator
GO


	g. WYZWALACZ INSTEAD OF INSERT NA TABELI PRACOWNICY SPRAWDZAJĄCY MODYFIKOWANE DANE DO TABELI PRACOWNICY- POPRAWNOŚĆ PESELA
Analogiczny przykład jak wyżej informuje o poprawności wprowadzanych danych - tym razem dla tabeli 'Pracownicy' szpitala podczas ich dodawania.
GO
CREATE TRIGGER TR_INSERT_Pracownicy ON Pracownicy
INSTEAD OF INSERT
AS
	DECLARE @TEXT NVARCHAR(256)
	DECLARE ITERATOR CURSOR FOR
	SELECT Imie, Nazwisko, Plec, Pesel, Stanowisko, StopienNaukowy, Wyplata, ID_typZatrudnienia, DataZatrudnienia, NrKontaktowy, Adres, Miasto FROM inserted
	OPEN Iterator
	DECLARE @imie VARCHAR(256)
	DECLARE @nazwisko VARCHAR(256)
	DECLARE @plec VARCHAR(256)
	DECLARE @stanowisko VARCHAR(256)
	DECLARE @pesel VARCHAR(256)
	DECLARE @dataurodzenia DATE
	DECLARE @stopienNaukowy VARCHAR(256)
	DECLARE @wyplata MONEY
	DECLARE @typZatrudnienia INT
	DECLARE @dataZatrudnienia DATE
	DECLARE @nrKontaktowy VARCHAR(256)
	DECLARE @adres VARCHAR(256)
	DECLARE @miasto VARCHAR(256)
	DECLARE @unique BIT
	DECLARE @peselGood BIT
	FETCH Iterator INTO @imie, @nazwisko, @plec, @pesel, @stanowisko, @stopienNaukowy, @wyplata, @typZatrudnienia, @dataZatrudnienia, @nrKontaktowy, @adres, @miasto
	WHILE (@@FETCH_STATUS = 0 ) BEGIN
		SET @peselGood = 1
		SET @unique = 1
		-- sprawdzenie czy pesel jest unique
		IF @pesel IN ( SELECT Pesel FROM Pracownicy ) BEGIN
			SET @TEXT = FORMATMESSAGE ('Nie dodano pracownika Pesel: %s. Pesel jest już w bazie danych',@pesel)
			SET @unique = 0
		END
		IF (@pesel IS NOT NULL ) BEGIN
			IF dbo.CheckPesel(@pesel) = 0
				SET @peselGood = 0
		END
		IF ( @peselGood = 1 AND @unique = 1) BEGIN
		INSERT INTO Pracownicy VALUES (@imie, @nazwisko, @plec, @pesel, @stanowisko, @stopienNaukowy, @wyplata, @typZatrudnienia, @dataZatrudnienia, @nrKontaktowy, @adres, @miasto)
		SET @TEXT = FORMATMESSAGE (
		'Dodano pracownika %s %s Pesel: %s',
		@imie, @nazwisko, @pesel
		)
		END
		IF (@peselGood = 0) BEGIN
		SET @TEXT = FORMATMESSAGE (
		'Nie dodano pracownika %s %s. Błędny Pesel: %s',
		@imie, @nazwisko, @pesel)
		END
	PRINT @TEXT
	FETCH Iterator INTO @imie, @nazwisko, @plec, @pesel, @stanowisko, @stopienNaukowy, @wyplata, @typZatrudnienia, @dataZatrudnienia, @nrKontaktowy, @adres, @miasto
END
CLOSE Iterator
DEALLOCATE Iterator
GO

	h. WYZWALACZ INSTEAD OF UPDATE NA TABELI PRACOWNICY SPRAWDZAJĄCY MODYFIKOWANE DANE DO TABELI PRACOWNICY- POPRAWNOŚĆ PESELA
Analogiczny przykład jak wyżej informuje o poprawności wprowadzanych danych - tym razem dla tabeli 'Pracownicy' szpitala podczas ich modyfikowania.
GO
CREATE TRIGGER TR_UPDATE_Pracownicy ON Pracownicy
INSTEAD OF UPDATE
AS
	DECLARE @TEXT VARCHAR(256)
	DECLARE ITERATOR CURSOR FOR
	SELECT ID, Imie, Nazwisko, Plec, Pesel, Stanowisko, StopienNaukowy, Wyplata, ID_typZatrudnienia, DataZatrudnienia, NrKontaktowy, Adres, Miasto FROM inserted
	OPEN Iterator
	DECLARE @id INT
	DECLARE @imie VARCHAR(256)
	DECLARE @nazwisko VARCHAR(256)
	DECLARE @plec VARCHAR(256)
	DECLARE @stanowisko VARCHAR(256)
	DECLARE @pesel VARCHAR(256)
	DECLARE @dataurodzenia DATE
	DECLARE @stopienNaukowy VARCHAR(256)
	DECLARE @wyplata MONEY
	DECLARE @typZatrudnienia INT
	DECLARE @dataZatrudnienia DATE
	DECLARE @nrKontaktowy VARCHAR(256)
	DECLARE @adres VARCHAR(256)
	DECLARE @miasto VARCHAR(256)
	DECLARE @peselGood BIT
	FETCH Iterator INTO @id, @imie, @nazwisko, @plec, @pesel, @stanowisko, @stopienNaukowy, @wyplata, @typZatrudnienia, @dataZatrudnienia, @nrKontaktowy, @adres, @miasto
	WHILE (@@FETCH_STATUS = 0 ) BEGIN
		-- sprawwdzenie pesela
		IF dbo.CheckPesel(@pesel) = 1
			SET @peselGood = 1
		ELSE
			SET @peselGood = 0
		PRINT (@peselGood)
		IF @peselGood = 1 BEGIN
			UPDATE Pracownicy
			SET Imie = @imie, Nazwisko = @nazwisko, Plec = @plec, Pesel = @pesel, Stanowisko = @stanowisko, StopienNaukowy = @stopienNaukowy, Wyplata = @wyplata,
			ID_typZatrudnienia = @typZatrudnienia, DataZatrudnienia = @dataZatrudnienia, NrKontaktowy = @nrKontaktowy, Adres = @adres, Miasto = @miasto
			WHERE Pracownicy.ID = @id
			SET @TEXT = FORMATMESSAGE (
			'Zmodyfikowano pracownika %s %s Pesel: %s',
			@imie, @nazwisko, @pesel
			)
		END
		IF @peselGood = 0 BEGIN
			SET @TEXT = FORMATMESSAGE (
			'Nie zmodyfikowano pracownika %s %s. Błędny Pesel: %s',
			@imie, @nazwisko, @pesel)
		END
	PRINT @TEXT
	FETCH Iterator INTO @id, @imie, @nazwisko, @plec, @pesel, @stanowisko, @stopienNaukowy, @wyplata, @typZatrudnienia, @dataZatrudnienia, @nrKontaktowy, @adres, @miasto
END
CLOSE Iterator
DEALLOCATE Iterator
GO


12.	Skrypt tworzący bazy danych

/*
TABLICE:
-- TWORZENIE PACJENTOW, KONTATKU DO PACJENTOW
-- TWORZENIE BADAŃ, WYNIKÓW, POMIARÓW PACJENTÓW
-- TWORZENIE OBJAWÓW, CHORÓB PACJENTÓW
-- TWORZENIE KATEGORII, LEKÓW, PRODUCENTÓW LEKÓW, INTERAKCJI, OBJAWÓW UBOCZNYCH
-- TWORZENIE STRUKTURY, PRACOWNIKÓW SZPITALA
-- TWORZENIE POBYTÓW PACJENTÓW W SZPITALU
-- TWORZENIE STRATEGII LECZENIA

Pacjenci [x], DaneKontaktowe [x],

BadanieMoczu [x], BadanieKrwi  [x], HistoriaWagi [x], WynikiDanychPsychologicznych [x]

Choroby [x], WszystkieChorobyPacjentow  [x],
Objawy [x], ObjawyPacjentow [x],

KategoriaLeku [x], Leki [x], ProducenciLekow [x], InterakcjeLekowe [x], ObjawyUboczneLekow [x], 

Oddzialy [x],
Pracownicy [x],
TypZatrudnienia [x]

Pobyty [x],

StrategieLeczenia [x]  (AktualneStrategieLeczenia [x], HistoriaStrategieLeczenia [x])
*/

-- TWORZENIE PACJENTOW, KONTATKU DO PACJENTOW

CREATE TABLE Pacjenci (
 	ID INT PRIMARY KEY IDENTITY(1,1),
 	Imie VARCHAR(255),
 	Nazwisko VARCHAR(255),
 	Plec CHAR(1),
 	DataUrodzenia DATE,
 	Pesel VARCHAR(11),
 	Palenie BIT,
 	Wzrost INT,
 );
 
 CREATE TABLE DaneKontaktowe (
	ID_Osoby INT IDENTITY(1,1),
	ID_Pacjenta INT,
	NumerKontaktowy VARCHAR(255),
	EMAIL VARCHAR(255),
	Adres VARCHAR(255),
	Miasto VARCHAR(255),
	Kraj VARCHAR(255),
	PRIMARY KEY (ID_Osoby, ID_Pacjenta),
	FOREIGN KEY(ID_Pacjenta) REFERENCES Pacjenci(ID)
);
 
-- TWORZENIE BADAŃ, WYNIKÓW, POMIARÓW PACJENTÓW
CREATE TABLE BadanieMoczu (
	ID_Pacjenta INT,
	DataBadania DATE,
	Barwa VARCHAR(255),
	Klarownosc BIT,
	OdczynPh FLOAT,
	CiezarMoczu FLOAT,
	Leukocyty BIT,
	Hemoglobina BIT,
	Bilirubina BIT,
	Urobilinogen BIT,
	Bialko BIT,
	Glukoza BIT,
	Ketony BIT,
	Azotyny BIT,
	PRIMARY KEY (ID_Pacjenta, DataBadania),
	FOREIGN KEY (ID_Pacjenta) REFERENCES Pacjenci(ID)
);

CREATE TABLE BadanieKrwi (
	ID_Pacjenta INT,
	DataBadania DATETIME,
	Erytrocyty FLOAT,
	Leukocyty FLOAT,
	Hemoglobina FLOAT,
	Hematokryt FLOAT,
	PlytkiKrwi FLOAT,
	Glukoza FLOAT,
	PRIMARY KEY (ID_Pacjenta, DataBadania),
	FOREIGN KEY (ID_Pacjenta) REFERENCES Pacjenci(ID)
);

CREATE TABLE HistoriaWagi (
	ID_Pacjenta INT,
	Waga INT,
	DataPomiaru DATE,
	PRIMARY KEY (ID_Pacjenta, DataPomiaru),
	FOREIGN KEY(ID_Pacjenta) REFERENCES Pacjenci(ID)
);

CREATE TABLE WynikiDanychPsychologicznych (
	ID_Pacjenta INT,
	Data DATE,
	TestBECCA INT,
	SkalaYOUNGA INT,
	TestMMPI2 INT,
	TestDUDIT INT,
	SkalaAUDIT INT,
	SkalaPANNS INT,
	PRIMARY KEY (ID_Pacjenta, Data),
	FOREIGN KEY(ID_Pacjenta) REFERENCES Pacjenci(ID),
);

-- TWORZENIE OBJAWÓW, CHORÓB PACJENTÓW

CREATE TABLE Choroby (
 	ID INT PRIMARY KEY,
 	NazwaChoroby VARCHAR(255)
 );

CREATE TABLE WszystkieChorobyPacjentow (
 	ID_Pacjenta INT,
 	ID_Choroby INT,
 	PRIMARY KEY (ID_Pacjenta, ID_Choroby),
 	FOREIGN KEY(ID_Pacjenta) REFERENCES Pacjenci(ID),
 	FOREIGN KEY(ID_Choroby) REFERENCES Choroby(ID),
 );
 
 CREATE TABLE Objawy (
	ID INT PRIMARY KEY,
	NazwaObjawu VARCHAR(255),
);

CREATE TABLE ObjawyPacjentow (
	ID_Pacjenta INT,
	ID_Objawu INT,
	DataWystapienia DATE,
	PRIMARY KEY (ID_Pacjenta, ID_Objawu),
	FOREIGN KEY(ID_Pacjenta) REFERENCES Pacjenci(ID),
	FOREIGN KEY(ID_Objawu) REFERENCES Objawy(ID),
);

-- TWORZENIE KATEGORII, LEKÓW, PRODUCENTÓW LEKÓW, INTERAKCJI, OBJAWÓW UBOCZNYCH

CREATE TABLE KategoriaLeku(
	IdKategorii INT Primary key,
	NazwaKategorii VARCHAR(256)
);

CREATE TABLE Leki (
 	ID INT PRIMARY KEY,
 	NazwaLeku VARCHAR(255),
 	Generacja INT,
 	Producent INT,
 	Kategoria INT,
 	SubstancjaCzynna VARCHAR(255),
 	IloscLekuNaStanie INT,
 	FOREIGN KEY(Kategoria) REFERENCES KategoriaLeku(IdKategorii),
 );
 
CREATE TABLE ProducenciLekow (
	ID INT PRIMARY KEY,
	Nazwa VARCHAR(256),
	NumerKontaktowy VARCHAR(255),
	Email VARCHAR(255),
	Adres VARCHAR(255),
	Kraj VARCHAR(255),
	UE BIT,
 );
 
CREATE TABLE InterakcjeLekowe (
	ID_LEK_1 INT,
	ID_LEK_2 INT,
	TypInterakcji VARCHAR(255),
	PRIMARY KEY (ID_LEK_1, ID_LEK_2),
	FOREIGN KEY(ID_LEK_1) REFERENCES LEKI(ID),
	FOREIGN KEY(ID_LEK_2) REFERENCES LEKI(ID)
);


CREATE TABLE ObjawyUboczneLekow (
	ID_LEK INT,
	ObjawUboczny VARCHAR(255),
	PRIMARY KEY (ID_LEK, ObjawUboczny),
	FOREIGN KEY(ID_LEK) REFERENCES LEKI(ID),
);


-- TWORZENIE STRUKTURY, PRACOWNIKÓW SZPITALA

CREATE Table Oddzialy(
	IdOddzialu INT Primary key,
	NazwaOddzialy VARCHAR(256),
	Kierownik INT,
	LiczbaMiejsc INT
);

CREATE TABLE TypZatrudnienia (
	ID INT PRIMARY KEY,
	Nazwa VARCHAR(256)
);

CREATE TABLE Pracownicy (
 	ID INT PRIMARY KEY IDENTITY(1,1),
 	Imie VARCHAR(256),
 	Nazwisko VARCHAR(256),
	Plec CHAR(1),
	PESEL VARCHAR(11),
 	Stanowisko VARCHAR(256),
 	StopienNaukowy VARCHAR(256),
 	Wyplata MONEY,
 	ID_typZatrudnienia INT,
 	DataZatrudnienia DATE,
 	NrKontaktowy VARCHAR(256),
 	Adres VARCHAR(256),
 	Miasto VARCHAR(256),
	FOREIGN KEY(ID_typZatrudnienia) REFERENCES TypZatrudnienia(ID)
 );
 
-- TWORZENIE POBYTÓW PACJENTÓW W SZPITALU

CREATE TABLE Pobyty (
	ID_pacjenta INT,
	DataPrzyjecia DATE,
	DataWypisu DATE,
	PRIMARY KEY (ID_Pacjenta, DataPrzyjecia),
	FOREIGN KEY(ID_Pacjenta) REFERENCES Pacjenci(ID),
	CHECK (DataWypisu>DataPrzyjecia)
);


-- TWORZENIE STRATEGII LECZENIA

/*
CREATE TABLE StrategieLeczenia (
	ID INT PRIMARY KEY IDENTITY(1,1),
	ID_Pacjenta INT,
	ID_Choroby INT,
	ID_Leku INT,
	DawkaLeku VARCHAR(255),
	LekarzProwadzacy INT,
	ID_Oddzialu INT,
	DataRozpoczecia DATE,
	DataZakonczenia DATE,
	FOREIGN KEY(ID_Pacjenta) REFERENCES Pacjenci(ID),
	FOREIGN KEY(ID_Choroby) REFERENCES Choroby(ID),
	FOREIGN KEY(ID_Leku) REFERENCES Leki(ID),
	FOREIGN KEY(LekarzProwadzacy) REFERENCES Pracownicy(ID),
	FOREIGN KEY(ID_Oddzialu) REFERENCES Oddzialy(IdOddzialu),
);

*/
--DROP TABLE  AktualneStrategieLeczenia

CREATE TABLE AktualneStrategieLeczenia (
	ID INT PRIMARY KEY IDENTITY(1,1),
	ID_Pacjenta INT,
	ID_Choroby INT,
	ID_Leku INT,
	DawkaLeku VARCHAR(255),
	LekarzProwadzacy INT,
	ID_Oddzialu INT,
	DataRozpoczecia DATE,
	FOREIGN KEY(ID_Pacjenta) REFERENCES Pacjenci(ID),
	FOREIGN KEY(ID_Choroby) REFERENCES Choroby(ID),
	FOREIGN KEY(ID_Leku) REFERENCES Leki(ID),
	FOREIGN KEY(LekarzProwadzacy) REFERENCES Pracownicy(ID),
	FOREIGN KEY(ID_Oddzialu) REFERENCES Oddzialy(IdOddzialu),
);

CREATE TABLE HistoriaStrategieLeczenia (
	ID INT PRIMARY KEY,
	ID_Pacjenta INT,
	ID_Choroby INT,
	ID_Leku INT,
	DawkaLeku VARCHAR(255),
	LekarzProwadzacy INT,
	ID_Oddzialu INT,
	DataRozpoczecia DATE,
	DataZakonczenia DATE,
	FOREIGN KEY(ID_Pacjenta) REFERENCES Pacjenci(ID),
	FOREIGN KEY(ID_Choroby) REFERENCES Choroby(ID),
	FOREIGN KEY(ID_Leku) REFERENCES Leki(ID),
	FOREIGN KEY(LekarzProwadzacy) REFERENCES Pracownicy(ID),
	FOREIGN KEY(ID_Oddzialu) REFERENCES Oddzialy(IdOddzialu),
);

13.	Typowe zapytania dla bazy danych

	1) FUNKCJE I WIDOKI 

	a. FUNKCJA wyliczająca wiek pacjenta 
SELECT ObliczWiek(2)

	b. WIDOK PODAJĄCY INFORMACJE O DNIACH POBYTU W SZPITALU I LICZBIE HOSPITALIZACJI
SELECT * FROM Info_Pobyty

	c. WIDOK INFORMUJĄCY O WYPEŁNIENIU ODDZIALÓW SZPITALNYCH PRZEZ PACJENTÓW
SELECT * FROM DostepneMiejscaNaOddzialach

	d. WIDOK pokazujący lekarzy i ich obecnych pacjentow
SELECT * FROM vw_Pacjenci_Lekarzy 

	e. FUNKCJA pokazująca lekarza i jego obecnych pacjentów
SELECT * FROM f_Pacjenci_Lekarza('Milena', 'Krajewska')

	f. FUNKCJA pokazująca lekarza i jego byłych pacjentów
SELECT * FROM f_Historia_Pacjentów_Lekarza('Milena', 'Krajewska')

	g. FUNKCJA pokazująca pacjenta i jego obecnych lekarzy
SELECT * FROM f_Lekarze_Pacjenta('Zofia', 'Janik')

	h. FUNKCJA pokazująca pacjenta i jego byłych lekarzy
SELECT * FROM f_Historia_Lekarzy_Pacjenta('Zofia', 'Janik')
	
	i. Widok zwracający częstość występowania danych jednostek chorobowych w szpitalu
SELECT * FROM CzestoscWystepowaniaJednostekChoorbowych

	2) WYZWALACZE I PROCEDURY

	a. w tabeli pacjenci znajdują się kolumny 'DataUrodzenia' i 'Pesel' na wypadek pacjentów nieposiadających numeru pesel i/lub udokumentowanej daty urodzenia - WYZWALACZ INSTEAD OF INSERT NA TABELI PACJENCI SPRAWDZAJĄCY DODAWANE DANE DO TABELI PACJENCI- POPRAWNOŚĆ/ZGODNOŚĆ PESELA I DATY
Przykład:
INSERT INTO Pacjenci VALUES
('Tymoteusz', 'Jasiński', 'M', '1972-05-04', '72050459950', 1, 178),
('Dominik', 'Kamiński', 'M', '1988-05-19', '88051960935', 0, 185),
('Lidia', 'Kaczmarek', 'K', '1928-05-12', '29051210920', 1, 184), -- zły pesel, dobry: 28051210920
('Norbert', 'Pawłowski', 'M', '1949-02-13', '49021367890', 1, 179), -- zły pesel, dobry: 49021367891
('Zygmunt', 'Sobczak', 'M', '2005-06-26', '05262649138', 1, 171),
('Wioletta', 'Jabłońska', 'K', '1953-11-18', NULL, 0, 187)

	b. WYZWALACZ INSTEAD OF UPDATE NA TABELI PACJENCI SPRAWDZAJĄCY MODYFIKOWANE DANE DO TABELI PACJENCI- POPRAWNOŚĆ/ZGODNOŚĆ PESELA I DATY
UPDATE Pacjenci
SET Pesel = '58032157277'
WHERE Pesel = '58032157278' -- nie przejdzie, bo byłby błędny pesel

SELECT * FROM Pacjenci
WHERE Pesel = '58032157278'

UPDATE Pacjenci
SET DataUrodzenia = '1958-04-21'
WHERE Pesel = '58032157278' -- nie przejdzie, bo byłby błędny pesel

UPDATE Pacjenci
SET DataUrodzenia = '1958-04-21'
WHERE Pesel = '58042157278' -- przejdzie, zmiana jest spójna

UPDATE Pacjenci
SET Nazwisko = 'Nowak'
WHERE Pesel = '76121257869' -- przejdzie, zmiana jest spójna

	c. WYZWALACZ INSTEAD OF INSERT NA TABELI PRACOWNICY SPRAWDZAJĄCY MODYFIKOWANE DANE DO TABELI PACJENCI- POPRAWNOŚĆ PESELA
INSERT INTO Pracownicy VALUES
('Wiesław', 'Laskowski', 'M', '29083059734', 'Pielęgniarz', 'Magister', 4886, 0, '1958-05-11', '+48 721675648', 'ul. Karminowa 136/29', 'Sędziszów Małopolski'),
('Tadeusz', 'Krawczyk', 'M', '44081854155', 'Lekarz', 'Doktor Habilitowany', 16752, 0, '1991-02-19', '+48 694041151', 'ul. Wrocławska 96', 'Bełżyce'), -- zły pesel, dobry 44081854150
('Milena', 'Pawlak', 'K', NULL, 'Lekarz', 'Doktor Habilitowany', 16752, 0, '2003-03-26', '+48 722240867', 'ul. Zacisze 41/39', 'Maków Podhalański')

INSERT INTO Pracownicy VALUES
('Janina', 'Maciejewska', 'K', '72052539942', 'Diagnostyk Laboratoryjny', 'Magister', 5863, 0, '2010-10-24', '+48 667925799', 'ul. Partyzantów 43/21', 'Sochaczew'),
('Janina', 'Maciejewska', 'K', '72052539942', 'Diagnostyk Laboratoryjny', 'Magister', 5863, 0, '2010-10-24', '+48 667925799', 'ul. Partyzantów 43/21', 'Sochaczew') -- nie przejdzie, ten sam PESEL

	d. WYZWALACZ INSTEAD OF UPDATE NA TABELI PRACOWNICY SPRAWDZAJĄCY MODYFIKOWANE DANE DO TABELI PACJENCI- POPRAWNOŚĆ PESELA
UPDATE Pracownicy
SET Nazwisko = 'Nowak'
WHERE Pesel = '44081854155' -- przejdzie, zmiana jest spójna

	e. Procedura dodająca strategię leczenia dla danego pacjenta (imie, nazwisko, pesel) przypisując mu lekarza
EXEC DodajLeczenie
	@imie_pacj = 'Mariola',
	@nazwisko_pacj = 'Krawczyk',
	@pesel_pacj = '70081814560',
	@imie_lek = 'Klaudia',
	@nazw_lek = 'Kaczmarczyk',
	@pesel_lek = '82030517264'

	f. Procedura wpisująca detale leczenia
EXEC UzupelnijLeczenie
	@id_leczenia = 7,
	@choroba = 'Zaburzenie osobowości',
	@lek = 'Olzapin',
	@dawka = 10,
	@oddzial = 'Oddział Ogólnopsychiatryczny'
GO

	g. Procedura wpisująca datę końcową leczenia
EXEC ZakonczLeczenie
	@id_leczenia = 4


14. Strategie pielęgnacji bazy danych (kopie zapasowe)
W celu pielęgnaci bazy danych za pomocą SQL Server utworzono backup bazy danych pt. "BazaDanychSzpitala-KopiaZapasowa", który zapisano na dysku. Dodatkowym zabezpieczeniem jest przechowywanie Projektu w prywatnym repozytorium na Githubie.  
